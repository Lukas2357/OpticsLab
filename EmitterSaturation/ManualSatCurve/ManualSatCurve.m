%
%,------------------------------------------------------------------------,
%| Manual saturation measurement analysis (Lukas Hunold @26/01/21)  V 2.1 |
%'------------------------------------------------------------------------'
%
%In this script a saturation curve can be generated and fitted from
%measured data. As input you might give a txt file including a list of the
%powers as well as one with the corresponding signal counts.

%Instead you can also measure the counts over time and change the power 
%stepwise in equal time intervalls. Giving the program the counts over
%time and the intervall params (start, length, laser levels), it will
%also generate the saturation curve. 

%In this case you should measure the power for some levels with a fixed 
%difference, starting with the highest (e.g. 10, 8, 6, 4, 2). If you then 
%provide the programm the highest and lowest level as well as the step size
%it fits the laserpower/level and uses this fit to get the correct powers 
%to the given levels in the measurement.

%Next the program fits the curve, plots the fit and returns the parameters.

%If you want to have a background correction activate the BgCorr option.
%Then you have to provide a background data (matlab data file) called 'bg'
%in the same folder. You can also generate the bg data by running this
%script with a bg measurement as input and activating SaveAsBg option.
%(make sure, that you disable the BgCorr option in this case)

close all
clear variables


%% ---- Optional functions ------------------------------------------------

%If you measured counts over time while stepwise changing power,activate:
computeCountsFromTemporalMeasurement  = true;  
%And give the name of your temporal count measurement txt file here:
signalFile = 'test';
%(All data files must be place in a folder 'Data' in this folder!)

%If you measured power for different levels and want to fit this, activate:
computePowerPerLevelFromMeasurement = true;
%And give the name of the txt file including your power measurement here:
powerFile  = 'power';

%If you do not activate one of the two options, provide a file
%StepCount.txt or StepPower.txt that gives the values directly.
%They have to include a list of counts or powers of the same length.

%If you want to use this program to generate a background file, activate:
saveResultAsBg  = false;
%And the signalFile you provide is used for the background calculation.

%If you want to use a background file Bg.txt for correction, activate:
bgCorrection    = true;
%(Bg.txt can either be provided manually or generated by upper option.
% Make sure to never activate saveResultAsBg and bgCorrection together!)

%If you want to save your saturation curve and the fit as png, activate:
saveResult   = true;
%Notice: You have to create a folder 'Result' in this folder first!


%% ---- Generate power/level ----------------------------------------------

%To generate the powers for each level, measure the power for some levels
%with a fixed difference, starting with the highest (e.g. 10, 8, 6, 4, 2)

if computePowerPerLevelFromMeasurement
    
    %---- Parameters to be predefined -------------------------------------
    
    MIN_LEVEL   = 6.4;   %lowest power level measured
    MAX_LEVEL   = 10;    %highest power level measured
    LEVEL_STEP = 0.1;    %level steps in which power was measured
    
    %If you think the actual power exciting your emitter is lower than your
    %measured one (e.g. due to objective absorbtion), plug the value here:
    POWER_FRACTION = 0.65;
    
    MIN_PLOT_LEVEL   = 6;      %Minimum laser level shown in the plot
    MAX_PLOT_LEVEL   = 20;     %Maximum laser level shown in the plot
    PLOT_LEVEL_STEP = 0.2;     %Level steps in which the power is plotted
    
    %---- Data Readout ----------------------------------------------------

    cd 'Data'  
    power = importdata([powerFile,'.txt']);  
    cd ..
    
    %---- Data Ordering ---------------------------------------------------
    
    measuredLevel  = flip(MIN_LEVEL:LEVEL_STEP:MAX_LEVEL)';
    measuredPower  = power(1:length(measuredLevel))*POWER_FRACTION;
    
    %---- Fit power/level -------------------------------------------------
    
    [powerFit] = fit(measuredLevel,measuredPower,'poly1');
    level = flip(MIN_PLOT_LEVEL:PLOT_LEVEL_STEP:MAX_PLOT_LEVEL);
    fitPower = powerFit.p1*level+powerFit.p2;
    
end


%% ---- Generate counts/power ---------------------------------------------

%If you have a measurement of counts over time, while changing the power,
%use the following code to generate the counts per power from that:

if computeCountsFromTemporalMeasurement
    %% ---- Parameters to be predefined -----------------------------------
    
    %The program will take an intervall around the center of a step for
    %averaging the counts. Give the start of the first step by START, the
    %time length of a step by STEP_TIME, the end time of your measurement
    %by STOP, the time difference between two measured points by TIME_BIN
    %and the range around the step center, where you want to average as
    %USED_TIME. First and last laser level used must be given also.
    
    TIME_BIN  = 0.01;    %time step between two measured counts
    
    START     = 18;      %time recorded before measurement start in s
    STOP      = 740;     %final time (use e.g. last entry of time vector)
    STEP_TIME = 20;      %time measuring at one power in s
    USED_TIME = 6;       %time around the center of the step that is used
    
    FIRST_LEVEL = 10;    %first laser level used
    LAST_LEVEL  = 6.4;   %last laser level used
    
    %If the absolute counts change over time (e.g. due to drifts), measure
    %the counts in the beginning and at the end for the same power and give
    %the ration here:
    COUNT_CHANGE_FRACTION = 0.9;
    %The program will correct the measured counts under the assumption of a
    %linear change in the normalized count rate over time.
    
    
    %% ---- Compute counts for each step ----------------------------------
    
    % Load the data:
    cd 'Data'   
    data  = importdata([signalFile,'.txt']);
    cd ..
    
    % Calculate the step counts from it:
    stepCount = find_step_counts(data,START,USED_TIME,STEP_TIME,...
                     STOP,TIME_BIN,COUNT_CHANGE_FRACTION);
    
    % And find the corresponding power steps:
    if computePowerPerLevelFromMeasurement
        stepPower = find_step_power(level,fitPower,stepCount,...
                                    FIRST_LEVEL,LAST_LEVEL);
    else
        cd 'Data'
        stepPower = importdata('StepPower.txt')
        cd ..
        fitPower = linspace(0,2*max(stepPower))
    end 
        
else           
    cd 'Data'
    stepCount = importdata('StepCount.txt')
    cd ..
end

    
%% ---- Background correction ---------------------------------------------

if bgCorrection
    cd 'Data'
    bg = importdata('Bg.txt');
    cd ..
    stepCount = stepCount - bg';
end


%% ---- Fit Saturation Curve ----------------------------------------------

%Define saturation fit function:
sat = @(I_0,P_0,b,x) I_0*x./(x+P_0) + b;
%Perform the fit:
[satFitResult] = fit(stepPower',stepCount',sat, 'StartPoint', ...
                     [max(stepCount),max(stepPower),min(stepPower)]); 
%Extract the parameters:
satFitConf  = confint(satFitResult);
P_sat       = satFitResult.P_0;
I_sat       = satFitResult.I_0/2;
errP_sat    = P_sat - satFitConf(1,2);
errI_sat    = I_sat - satFitConf(1,1)/2;
%Construct the fit curve:
satFit = 2*I_sat*fitPower./(fitPower+P_sat) + satFitResult.b;
%Plot the fit curve with the data:
plot_fit(stepPower,stepCount,fitPower,satFit,P_sat,errP_sat,I_sat,errI_sat)


%% ---- Save as Background ------------------------------------------------

if saveResultAsBg
    bg = stepCount';
    cd 'Data'  
    save Bg.txt bg -ascii
    cd ..
end


%% ---- Save Result -------------------------------------------------------

if saveResult
    cd 'Result'  
    saveas(gcf,signalFile,'png');      %Save Plot in output folder
    cd ..
end


%% ---- Used functions ----------------------------------------------------

%Function to find the counts for each step:
function stepCount = find_step_counts(data,start,used_time,step_time,...
                                   stop,time_bin,count_change_fraction)
                                   
    time   = data(:,1)/1000;        %time in s (for data in ms!)
    counts = data(:,2);             %counts per time 
    
    %In the following extract the mean counts of the predefined range
    %around the center of a step and return it as 'StepCount':
    
    stepCenter = (start+used_time/2):step_time:(stop+used_time/2);
    stepLb = start:step_time:stop;
    stepUb = (start+used_time):step_time:(stop+used_time);
    lbCount = counts(stepLb/time_bin);      %lb = lower bound
    ubCount = counts(stepUb/time_bin);      %ub = upper bound
    
    stepCount = 1:length(stepCenter);
    for i=1:length(stepCenter)
        stepCount(i) = mean(counts(stepLb(i)/time_bin:stepUb(i)/time_bin));
    end
    
    %If the absolute counts over time changes linearly correct this by:
    stepCorrection = linspace(1,count_change_fraction,length(stepCount));
    stepCount = stepCount./stepCorrection;
    
    figure
    plot(time,counts,'kx','MarkerSize',1)
    hold on
    plot(stepLb, lbCount, 'bx','MarkerSize',10)
    hold on
    plot(stepUb, ubCount, 'gx','MarkerSize',10)
    hold on
    plot(stepCenter, stepCount, 'rx','MarkerSize',10)
    xlim ([0,max(time)])
    xlabel ('time / s')
    ylabel ('APD cps')
    legend ('APD counts', 'lower bound counts', 'upper bound counts', ...
            'Step count (corrected)', 'Location', 'best')
    
end

%Function to find the power for each step:
function stepPower = find_step_power(level,fitPower,stepCount,...
                                     first_level,last_level)
    firstPower = fitPower(level==first_level);
    lastPower  = fitPower(level==last_level);
    nStep = length(stepCount);
    stepPower  = linspace(firstPower,lastPower,nStep);
end

%Function to plot the fit:
function plot_fit(stepPower,stepCount,fitPower,satFit,P_sat,errP_sat,...
                  I_sat,errI_sat)
    figure
    plot(stepPower, stepCount, 'bx','MarkerSize',5);
    hold on
    plot(fitPower,satFit,'r--')
    xlim ([0,max(fitPower)])
    xlabel ('power / mW')
    ylabel ('APD cps')
    legend('off')
    dim = [0.55 0.3 0.4 0];
    str = {sprintf('P_{sat} = (%.2f +/- %.2f) mW'  ,P_sat,errP_sat), ...
      sprintf('I_{sat} = (%.0f +/- %.0f) kcps',I_sat/1000,errI_sat/1000)};
    annotation('textbox',dim,'String',str,'FitBoxToText','on');
end


%% ---- Protocol of updates -----------------------------------------------

% 09.02.20 (V2.0):  - Introduction of sections
%                   - Introduction of 3 new functions for simplification
% 26.01.21 (V2.1):  - Title changed

